// actions/quote.ts
'use server'; // Mark all functions in this file as Server Actions

import { createServerSupabase } from '@/lib/supabase/server';
import { calculateInstantQuote, PricingInput, pricingInputSchema } from '@/lib/pricing';
import { getUserAndProfile } from '@/lib/auth';
import { z } from 'zod';
import { revalidatePath } from 'next/cache'; // To revalidate data on relevant paths after an action
import { redirect } from 'next/navigation';

// --- Generic Authorization Helper (copied from actions/catalog.ts for consistency) ---
async function authorizeAdminOrStaff() {
  const { user, profile } = await getUserAndProfile();
  if (!user || !profile || !['admin', 'staff'].includes(profile.role)) {
    redirect('/dashboard?error=UnauthorizedAccess'); // Redirect to customer dashboard
    // It's crucial to throw an error here to stop execution if redirect doesn't immediately exit
    throw new Error('Unauthorized: Admin or Staff role required.');
  }
  return { user, profile };
}

/**
 * Server Action to calculate an instant quote based on user selections.
 * This function handles the server-side logic and returns the quote result.
 */
export async function getInstantQuoteResult(input: PricingInput) {
  // Validate input using Zod schema
  const validatedInput = pricingInputSchema.safeParse(input);
  if (!validatedInput.success) {
    console.error('Validation error for getInstantQuoteResult:', validatedInput.error);
    return { error: 'Invalid input provided.', details: validatedInput.error.flatten() };
  }

  const { user } = await getUserAndProfile();
  if (!user) {
    return { error: 'Unauthorized: User not authenticated.' };
  }

  // Fetch the user's profile to get their region for rate card selection
  const supabase = createServerSupabase();
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('region')
    .eq('id', user.id)
    .single();

  if (profileError) {
    console.error('Error fetching user profile for region:', profileError);
    return { error: 'Failed to retrieve user region for pricing.' };
  }

  const region = profile?.region || 'default';

  const quoteResult = await calculateInstantQuote({ ...validatedInput.data, region });

  if (!quoteResult) {
    return { error: 'Failed to calculate instant quote. Please check provided data.' };
  }

  return { data: quoteResult };
}


/**
 * Server Action to calculate an instant quote and save it as a draft.
 * This consolidates calculation and saving into one secure server-side operation.
 */
export async function calculateAndSaveDraftQuote(input: PricingInput) {
  // 1. Authenticate user and get profile
  const { user, profile } = await getUserAndProfile();
  if (!user || !profile) {
    return { error: 'Unauthorized: User not authenticated or profile missing.' };
  }

  // 2. Validate input using Zod schema
  const validatedInput = pricingInputSchema.safeParse(input);
  if (!validatedInput.success) {
    console.error('Validation error for calculateAndSaveDraftQuote:', validatedInput.error);
    return { error: 'Invalid input provided.', details: validatedInput.error.flatten() };
  }

  // 3. Calculate the quote
  const calculateResult = await getInstantQuoteResult(validatedInput.data);
  if (calculateResult.error) {
    return { error: calculateResult.error };
  }
  const quoteResult = calculateResult.data;

  // 4. Save the quote and its line items
  const supabase = createServerSupabase();

  try {
    // a. Create the main quote record
    const { data: newQuote, error: quoteError } = await supabase
      .from('quotes')
      .insert({
        customer_id: profile.id, // Link to the current user's profile ID (acting as customer_id)
        created_by: profile.id,
        status: 'draft',
        currency: quoteResult.pricing_breakdown.currency,
        subtotal: quoteResult.pricing_breakdown.final_subtotal,
        tax: quoteResult.pricing_breakdown.tax_amount,
        shipping: quoteResult.pricing_breakdown.shipping_amount,
        total: quoteResult.line_total,
        region: validatedInput.data.region || 'default',
        notes: 'Instant quote generated by customer.',
      })
      .select('id')
      .single();

    if (quoteError) {
      console.error('Error creating quote:', quoteError);
      throw new Error(quoteError.message);
    }

    // b. Create the quote item(s)
    const { error: itemError } = await supabase
      .from('quote_items')
      .insert({
        quote_id: newQuote.id,
        part_id: quoteResult.part_id,
        material_id: quoteResult.material_id,
        finish_id: quoteResult.finish_id,
        tolerance_id: quoteResult.tolerance_id,
        quantity: quoteResult.quantity,
        unit_price: quoteResult.unit_price,
        line_total: quoteResult.line_total,
        pricing_breakdown: quoteResult.pricing_breakdown as any, // Cast to any as jsonb type requires it
      });

    if (itemError) {
      console.error('Error creating quote item:', itemError);
      throw new Error(itemError.message);
    }

    // c. Log activity
    const { error: activityError } = await supabase
      .from('activities')
      .insert({
        actor_id: profile.id,
        customer_id: profile.id,
        quote_id: newQuote.id,
        type: 'quote_draft_saved',
        data: { quoteId: newQuote.id, total: quoteResult.line_total },
      });

    if (activityError) {
      console.warn('Failed to log quote draft activity:', activityError);
    }

    // Revalidate customer quotes page cache if applicable
    revalidatePath('/quotes');
    revalidatePath('/dashboard');
    revalidatePath('/admin/quotes'); // Also revalidate admin quotes page

    return { data: { quoteId: newQuote.id } };

  } catch (error: any) {
    console.error('Server Action Error: calculateAndSaveDraftQuote failed:', error.message);
    return { error: error.message || 'Failed to save the draft quote.' };
  }
}

/**
 * Server Action to fetch all quotes for the admin panel.
 * Includes customer and creator profile details for display.
 */
export async function getAllQuotesForAdmin() {
  await authorizeAdminOrStaff(); // Ensure only authorized users can fetch
  const supabase = createServerSupabase();

  const { data, error } = await supabase
    .from('quotes')
    .select(`
      id,
      status,
      total,
      currency,
      created_at,
      updated_at,
      customers (name),
      profiles (full_name, email, role)
    `)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching all quotes for admin:', error);
    return { error: 'Failed to retrieve all quotes.' };
  }
  return { data };
}

/**
 * Server Action to fetch a single quote with all its details for the admin panel.
 */
export async function getQuoteDetailsForAdmin(quoteId: string) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  const { data: quote, error: quoteError } = await supabase
    .from('quotes')
    .select(`
      *,
      customers (id, name, billing_address, shipping_address),
      profiles (id, full_name, email, role),
      quote_items (
        *,
        parts (id, file_name, file_url, preview_url),
        materials (id, name),
        finishes (id, name),
        tolerances (id, name)
      )
    `)
    .eq('id', quoteId)
    .single();

  if (quoteError) {
    console.error(`Error fetching quote ${quoteId} for admin:`, quoteError);
    return { error: 'Failed to retrieve quote details.' };
  }
  return { data: quote };
}

/**
 * Server Action to update the status of a quote.
 */
export async function updateQuoteStatus(quoteId: string, newStatus: string) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  // Basic validation for newStatus (should match enum in schema)
  const validStatuses = ['draft','sent','accepted','rejected','expired','abandoned','paid','in_production','completed'];
  if (!validStatuses.includes(newStatus)) {
    return { error: 'Invalid quote status provided.' };
  }

  const { data, error } = await supabase
    .from('quotes')
    .update({ status: newStatus, updated_at: new Date().toISOString() })
    .eq('id', quoteId)
    .select('id, status')
    .single();

  if (error) {
    console.error(`Error updating status for quote ${quoteId}:`, error);
    return { error: `Failed to update quote status: ${error.message}` };
  }

  // Log activity
  const { user, profile } = await authorizeAdminOrStaff();
  const { error: activityError } = await supabase
    .from('activities')
    .insert({
      actor_id: user.id,
      quote_id: quoteId,
      type: 'quote_status_updated',
      data: { old_status: data?.status, new_status: newStatus }, // Old status might be null here
    });

  if (activityError) {
    console.warn('Failed to log quote status update activity:', activityError);
  }

  revalidatePath(`/admin/quotes`);
  revalidatePath(`/admin/quotes/${quoteId}`);
  revalidatePath(`/quotes/${quoteId}`); // Also revalidate customer view
  revalidatePath(`/admin/dashboard`); // Status change affects dashboard KPIs

  return { data };
}

/**
 * Server Action to update line items of a quote.
 * This is a simplified version, allowing updates to quantity, material, finish, tolerance.
 * More complex scenarios might require recalculating pricing, which would involve calling calculateInstantQuote.
 */
export async function updateQuoteLineItem(itemId: string, updates: {
  quantity?: number;
  material_id?: string;
  finish_id?: string;
  tolerance_id?: string;
  unit_price?: number; // Admin might manually adjust unit price
  line_total?: number; // Admin might manually adjust line total
  pricing_breakdown?: any; // If pricing is recalculated manually
}) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  const { data, error } = await supabase
    .from('quote_items')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', itemId)
    .select('id, quote_id')
    .single();

  if (error) {
    console.error(`Error updating quote item ${itemId}:`, error);
    return { error: `Failed to update quote line item: ${error.message}` };
  }

  // After updating a line item, the parent quote's total needs to be recalculated.
  // This is a crucial step that is omitted in a simple update.
  // For a production system, you'd likely have a database trigger or a separate
  // server action that re-calculates quote.subtotal, tax, and total based on its items.
  // For simplicity, we are not implementing full recalculation here.
  // However, we will revalidate the relevant paths.

  revalidatePath(`/admin/quotes`);
  revalidatePath(`/admin/quotes/${data?.quote_id}`);
  revalidatePath(`/quotes/${data?.quote_id}`); // Revalidate customer view

  return { data };
}

/**
 * Server Action to add a new line item to a quote.
 * This would typically come from adding another part with specific options.
 * Requires a part_id, material_id, finish_id, tolerance_id, quantity.
 */
export async function addQuoteLineItem(quoteId: string, itemData: {
  part_id: string;
  material_id: string;
  finish_id: string;
  tolerance_id: string;
  quantity: number;
}) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  // First, calculate the pricing for the new item
  const pricingInput: PricingInput = {
    partId: itemData.part_id,
    materialId: itemData.material_id,
    finishId: itemData.finish_id,
    toleranceId: itemData.tolerance_id,
    quantity: itemData.quantity,
    region: 'default' // Admin might manually specify region later, or rely on customer's region
  };
  const { data: quoteResult, error: pricingError } = await getInstantQuoteResult(pricingInput);

  if (pricingError || !quoteResult) {
    return { error: pricingError || 'Failed to calculate pricing for new line item.' };
  }

  const { data, error: insertError } = await supabase
    .from('quote_items')
    .insert({
      quote_id: quoteId,
      part_id: quoteResult.part_id,
      material_id: quoteResult.material_id,
      finish_id: quoteResult.finish_id,
      tolerance_id: quoteResult.tolerance_id,
      quantity: quoteResult.quantity,
      unit_price: quoteResult.unit_price,
      line_total: quoteResult.line_total,
      pricing_breakdown: quoteResult.pricing_breakdown as any,
    })
    .select('id')
    .single();

  if (insertError) {
    console.error(`Error adding line item to quote ${quoteId}:`, insertError);
    return { error: `Failed to add line item: ${insertError.message}` };
  }

  // You would typically re-calculate the parent quote's totals here.
  // For now, revalidate paths.
  revalidatePath(`/admin/quotes`);
  revalidatePath(`/admin/quotes/${quoteId}`);
  revalidatePath(`/quotes/${quoteId}`);

  return { data };
}

/**
 * Server Action to delete a quote line item.
 */
export async function deleteQuoteLineItem(itemId: string) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  // Get the quote_id before deleting to revalidate correctly
  const { data: itemToDelete, error: fetchError } = await supabase
    .from('quote_items')
    .select('quote_id')
    .eq('id', itemId)
    .single();

  if (fetchError || !itemToDelete) {
    console.error(`Error finding quote item ${itemId} for deletion:`, fetchError);
    return { error: 'Failed to find quote item for deletion.' };
  }

  const { error } = await supabase
    .from('quote_items')
    .delete()
    .eq('id', itemId);

  if (error) {
    console.error(`Error deleting quote item ${itemId}:`, error);
    return { error: `Failed to delete quote line item: ${error.message}` };
  }

  // You would typically re-calculate the parent quote's totals here.
  revalidatePath(`/admin/quotes`);
  revalidatePath(`/admin/quotes/${itemToDelete.quote_id}`);
  revalidatePath(`/quotes/${itemToDelete.quote_id}`);

  return { data: { message: 'Line item deleted successfully.' } };
}

/**
 * Server Action to delete an entire quote.
 */
export async function deleteQuote(quoteId: string) {
  await authorizeAdminOrStaff();
  const supabase = createServerSupabase();

  const { error } = await supabase
    .from('quotes')
    .delete()
    .eq('id', quoteId);

  if (error) {
    console.error(`Error deleting quote ${quoteId}:`, error);
    return { error: `Failed to delete quote: ${error.message}` };
  }

  revalidatePath(`/admin/quotes`);
  revalidatePath(`/quotes`); // Revalidate customer quotes list
  revalidatePath(`/admin/dashboard`); // Affects dashboard KPIs

  return { data: { message: 'Quote deleted successfully.' } };
}
